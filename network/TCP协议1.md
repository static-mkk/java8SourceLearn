

## tcp基础知识

![image](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843ZPb6tFLvCVuXEn98khfs7y2KRvOV0ia5icVByzIK3aAKRURuVZKagsKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)


序列号：tcp在建立连接时，计算机生成的随机数，通过SY包传送给接收端，每发送一次数据，就累加一次该数据的字节数（选择重传的数据包除外），用来解决网络包乱序的情况。

确认应答号：只接收端希望下一次传输的数据包的序列号。表示接收端已经成功接收了序列号对应的数据包以序列号及之前的数据包。用来保证数据包的不会丢。如果丢失就会发生重传。


控制位：
    
    - ACK = 1时，确认应答 有效，tcp规定，除了最初建立连接的SYN包之外的数据包，ACK必须设置为0.
    - RST = 1时，表示tcp连接中出现异常，必须强制断开连接
    - SYN = 1时，希望建立连接，并在其序列号字段中设置初始值
    - FIN = 1时，表示今后不会再有数据发送，希望断开连接。
    

为什么需要tcp层？

    - 因为IP层是不可靠的，当我们需要可靠的数据传输时，就需要有个协议来保证，tcp就是来保证可靠的数据传输服务的，他确保接收端接受的网络包是无损的、无间隔的、非冗余的和按序的。


什么是tcp？
    
> tcp是面向连接的、可靠的、基于字节流的传输层通信协议。

- 面向连接：指的是  1对1 的连接，不想udp协议那样，可以同时向多个主机发送消息，tcp无法实现一对多。
- 可靠的：无论网络链路中怎么变化，前提是网络是通的，tcp都可以保证一个报文一定能到达对端。不回因为一时的网络拥塞，网线断开而导致数据包丢失。重传机制。
- 字节流：消息是没有边界的，所以无论我们的消息有多大，都可以进行传输。并且消息是有序的，即使它收到了后面的字节，也不会扔给应用程序去处理，同时会丢弃掉重复报文。


连接：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括socket、序列号和窗口大小，称之为连接。

所以一个tcp连接有三个要素：由ip地址和端口组成的socker、随机数的序列号、窗口大小

tcp可以由一个4元祖确定一个连接：源地址 + 源端口 + 目标地址 + 目标端口

服务器端tcp的最大连接数？
    
    - 理论上最大TCP连接数 = 客户单的ip数 X 客户端的端口数 约为 2^48次方
    - 实际os中每个进程都有一个最大打开文件描述符数：一个socket实际也是一个文件，所以受到限制，可以通过ulimit进行配置。
    - 内存限制：每个连接都会占用一定的内存，而os是有限的。
     

## tcp 和 udp 的区别

- tcp面向连接的，传输数据之前一定要先建立连接；udp不需要建立连接，即可传输数据
- tcp是 1对1 的，而udp是1对1，一对多，多对多的
- tcp是可靠的，udp不保证可靠交付数据
- tcp有流量控制，拥塞控制；udp没有
- tcp首部固定20字节开销，并且可能还有选项字段的额外开销，而udp首部只有8个字节，并且固定不变，开销较小


应用场景：

    1. tcp：ftp文件传输、http、https
    2. udp：dns、视屏直播、广播通信


## tcp建立连接

3次握手：



为什么是三次握手？

    tcp连接是保证可靠性和流量控制维护的某些状态信息，包括socket，序列号和窗口大小。
    - 三次握手可以阻止历史重复连接的初始化（主要原因）
        
        第三次握手的目的是校验服务器端的确认号，防止历史连接。当旧的连接比新的连
        接连接还要更早到达接收端，服务端产生syn/ack数据包后，客户端验证失败后，就
        会发送RSH数据包中断连接。没有第三次握手，就无法分辨是否是历史连接，序列号
        也是错误的，就会导致服务器端的确认号和客户端的序列号不相符合逻辑，造成问
        题。
    
    - 三次握手才可以同步双方的初始序列号 
    - 三次握手可以避免资源浪费
    
        如果是2次连接，每次有个syn数据包过来，服务器就会创建一个连接，如果syn是
        因为网络延迟，发送端重试的，就会导致资源的浪费，因为此时客户端已经新建了
        一个连接请求，客户端的端口号已经不同了，所以，服务器端很多连接都是无效的
        ，造成了资源的浪费。
    
    
summary：TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。


MTU:一个网络包的最大长度，以太网中一般为1500字节
MSS:出去IP和TCP头部之后，一个网络包能容纳的TCP数据的最大长度。


## 4次挥手

过程描述：客户端向服务器发送FIN数据包，进入FIN_WAIT_1状态，服务器收到，并回复ack确认包，服务器端进入CLOSE_WAIT,客户端进入FIN_EAIT_2；当服务器端也发送了Fin数据包，服务器端进入LAST_ACK,客户端收到后，进入TIME_WAIT，客户端返回确认号后，服务器端接收到后，进入CLOSE状态；客户端TIME_WAIT等待2MSL后，进入CLOSE状态。

![image](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843KaMMu2mHfFLZNgiaREDZ5JicRYrlaiciayQjh9HDsacxIbMT0emGUpAX5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)


为什么要4次挥手？

- 客户端关闭连接，只表示客户端不会再发送数据，此时客户端还能接收数据，服务器端还能发送和接受数据。
- 等到服务器端不在发送数据后，服务器端发送FIN包。


为什么TIME_WAIT等待时间是 2MSL？

如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。

MSL:最大报文生存时间，他是任何报文在网络上存在的最长时间，超过这个时间的报文将被丢弃。
TTL：ip头部中的字段，表示ip数据包经过的最大路由数。没经过一个处理它的路由就-1，此值为0时，数据包也会被丢弃。

为什么要有 TIME_WAIT 状态？

- 防止具有相同四元组的旧数据包被收到
 
    - 经过2MSL这个时间，足以让两个方向上的数据包全部被丢弃，使得原来连接的数据包在网络中都自然的消失。

- 保证被动关闭方能正确关闭，即保证最后的ack能让被动关闭方关闭接收。


 如果TIME_WAIT时间过短或者没有，会怎样？
 
 如果客户端最后发送的ack确认号在网络中丢失，刚好有相同的socket四元组建立连接，服务器还处于last_ack状态，收到syn建立连接的请求就直接发送RST中断连接的报文了。导致客户端无法连接。
 
 
 如果TIME_WAIT时间足够长？
 
 帮助服务器端正常关闭连接，因为如果ack报文丢失，服务器超时会重新发送fin包，让客户端重新发送ack包，保证服务器端正常关闭。


过多的TIME_WAIT状态主要危害有：
    
    - 内存资源的占用
    - 端口资源的占用









    




