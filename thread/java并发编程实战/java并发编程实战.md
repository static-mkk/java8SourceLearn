
---

## 第三章： 对象的共享

---

```
可见性：只能修饰一个变量，目的是让所有线程能够看到最新的该变量的值。即，一个线程修改该变量后，会把该变量立即同步到共享内存中，并且禁止了cpu的乱序优化。使得每个线程读取到的都是最新的值。但是并不具有原子性，所以会有脏数据产生。
```


- 3.1.2 对于64位的类型，如double和long类型，如果不加volatile关键字，可能会使读取到的值，为一个随机数，因为jvm是分成两个32位来进行读取的（不加volatile关键只）。其他的类型，不加volatile，只会读到旧值，不会读成随机数。


- 3.4.1 Final 域
Final类型的域是不可修改的，但是Final域引用的对象是可以改变的。即Final A a = new A();不可以再 a = new A(); 但是可以，a.setXXX(); Final是线程安全的，是不可变的。


- 3.4.2 volatile只有可见性，没有原子性。
这里说的使用volatile关键字和final类型的对象，来发布不可变对象。是线程不安全的。
这一节再看

- 3.5.1 不正确的发布：多个线程对一个对象的发布，看到的状态不一致，就是不正确的发布。此时，如果没有足够的同步机制，那么，多线程处理共享资源的时候，就会产生问题。


- 3.5.3 安全发布对象的常见模式：
措施：在发布和使用该对象时，都必须进行同步。

--- 

## 第五章：基础构建模块

```
同步容器都是现成安全的，但是在某些情况下，需要加锁来完成复合操作。如：Vector的迭代器的在遍历的时候，会先检查集合的大小，然后才会进行操作。所以当一个线程在对一个vector进行操作之后，另一个线程再对其遍历操作，就会触发fast-fail机制。造成异常。在迭代期间修改计数器，hasNext和next方法都会触发快速失败机制。
```


## 第六章：结构化并发应用程序


1. 大多数并发应用程序都是围绕任务执行来构造的。

2. 在web请求中，服务器必须处理 套接字的io以读取和写回响应，这些操作可能会由于网络阻塞或者连通性问题而被阻塞，服务器还可能执行文件IO和数据库的连接，这些操作也可能导致阻塞。此时，服务器的资源利用率很低，线程在等待io操作，而cpu却处于空闲状态。

3. 线程串行执行的好处，当有少量请求，并且处理时间比较长，串行执行可以。

4. 无限创建线程的缺点
    - i. 线程的声明周期开销很高。线程的创建、销毁都需要消耗CPU，占用时间。
    - ii.资源消耗。活跃的线程会存活在内存中，大量的线程会占用很多内存。
    - iii.稳定性。当可以创建的线程数是有上限的。不同平台不同，根据jvm配置也可能不同。

5. 线程数量的标准：有足够多的线程使CPU处于忙碌状态即可，再多创建线程，会使得性能降低。

6. Executor框架：
    - 6.1 任务是一组逻辑的工作单元。就是一个runable中的run方法执行的逻辑。
    - 6.2 线程是使得任务异步执行的机制。
    - 6.3 executor是生产-消费模式，把任务的提交，和执行任务进行了解耦，而且，还有一系列生命周期的方法。比如executorService的isShutdown();等等
    - 6.4 通过executor可以实现各种调优，管理，监视，记录日志，错误报告等其他功能？？？？
    - 6.5 线程池调用shutdown()方法之后，在进行submit任务，则会根据拒绝策略进行处理。
    - 6.6 延迟任务和周期任务
    - 6.6.1Time类中会存在以下缺陷：1，time类在执行所有任务的时候，都会只创建一个线程。所以，如果一个任务执行时间较长，等到另外的任务被执行时，可能会被连续调用这段时间应该执行的次数，或者这段时间直接不执行该任务。2，time如果发生了异常，time类并不捕获异常，所以，该类就从异常程序走掉，所有的任务也都不会再执行。这就是线程泄露。
    - 6.7 任务有创建，提交，开始，完成4中状态，已经提交但是还没有开始的任务可以取消，已经开始，但是没有完成的线程，不能取消，只能通过响应中断来取消。
    - 6.8 executorservice中的所有submit方法都会返回一个future，用来获取任务执行的结果或者取消任务等。
    - 6.9 get()方法是线程安全的。任务的提交和获取结果，都是安全发布属性的。get有两个异常，被中断或者遇到exception。get方法可以设置超时时间，过期就不再需要了。
    - 6.10 只有当大量的相同的任务相互独立时，才能体现将任务分配到多个线程中带来的性能的提升。

## 第八章：线程池的使用
1. 虽然Executor框架为定制和修改执行策略提供了相当大的定制的灵活性，但是并不是多有的任务都适合所有的执行策略。比如：
    - i.依赖性的任务。即，如果提交的任务依赖于其他任务，这时候就可能会发生活跃性问题。从而造成死锁。
    - ii.使用线程封闭机制的任务。单线程的executor，可以确保任务不会被并发的执行，使得你能够放宽对线程安全的要求。对象在这些线程中，即使不是同步的，也不会有安全的问题。如果将线程池的线程改为多线程的环境，那么就会丢失安全性。
    - iii. 对响应时间敏感的任务。如果一个运行时间比较长的任务提交到单线程的executor中，或者只包含少量线程的线程池中，就会降低executor管理的服务的响应时间。用户体验会比较差。

2. 只有当线程本地值的生命周期受限于任务的生命周期时，在线程池中使用ThreadLocal才是有意义的，而在线程池中的线程不应该使用ThreadLocal在任务之间传递值。

3. 只有在线程池中的任务都是同类型，并且相互独立时，线程池的性能才能达到最佳状态。
4. 如果较长事件任务和较短任务一起，可能会导致所有线程执行较长事件任务，造成拥堵。用户体验差。如果有依赖关系的线程，可能会造成死锁。
5. 执行任务的线程需要等待其他线程中的资源，从而堵塞，这种现象称为饥饿死锁。
6. 在执行较长的任务时，使用一个带有超时的方法。即，当任务如果超时，然后重新将该任务放回等待队列，然后线程会被释放，执行其他任务。这样不会因为耗时任务较长，而导致其他任务饥饿的现象。
7. 正确的设置线程池的大小：线程数量过多，相会对很少的CPU和内存资源进行竞争，浪费内存，消耗资源。线程过少，会导致很多空闲处理器不执行任务，降低了吞吐量。
8. 正确线程池大小公式：


9. 线程基本大小：线程池中，工作队列没有满时的线程数量。
10. 线程最大大小：在线程池中，工作队列中已经满了，此时会创建新的线程，数量可以大于线程基本大小，但是不能超过这个最大大小。
11. 存活时间：如果某个线程的空闲时间已经超过了这个时间，那么就会回收这个线程。从而降低不必要的消耗。
12. newFixedThreadPool工厂方法创建的线程池的基本线程大小和最大大小为参数中的值，而且线程不会超时。newCachedThreadPool工厂方法，线程的最大大小为Integer的最大值，基本大小设置为0，超时时间为1分钟。所以他会根据任务需求，创建线程（一个任务一个需求），在线程超时之后，会回收线程。
13. 有界队列有助于避免资源耗尽的情况发生，但是他会带来新问题：当任务队列被填满之后，如何处理新的任务。这时候就需要拒绝策略来处理了。
14. 在使用有限工作队列时，队列的大小调节需要和线程池的大小一起调节。否则，不能达到最优。
15. 饱和策略：
    - i.当有界队列被填满后，饱和策略就开始发挥作用。
    - ii.jdk提供了几种不同的饱和策略，AbortPolicy,CallerRunsPolicy,DiscardOldPolicy
    - iii.终止策略是默认的饱和策略（Abort），该策略会抛出RejectdExecutionException。调用者可以捕获这个异常，来进行处理。
    - iv.当提交的任务无法保存到任务队列等待执行，抛弃策略（Discard）会抛弃掉该任务。
    - v.抛弃最旧的策略（Discard-old）会抛弃下一个将要执行的任务，然后重新提交新的任务。但是如果在一个优先级的队列中，他会抛弃优先级最高的，因此，他不适合和优先级队列一起使用。
    - vi.调用者运行策略（caller-Runs）是一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退搞调用者，降低任务流量。？？？？这个策略优点复杂，需要再看

16. 线程工厂：线程池创建线程都是通过线程工厂完成的。
17. 在调用线程池构造函数创建线程池之后，也可以使用一些setter方法来配置线程池的属性。也可以使用unconfigurableExecutorService来配置成不能使用setter方法来配置。
18. 扩展ThreadPoolExecutor：它提供了几个在子类中可以改写的方法：beforeExcute、afterExecute和terminated。afterExecute在run方法结束后执行，无论是正常退出还是异常退出（如果任务完成后带一个error，不会执行）。如果beforeExecute抛出异常，则任务不会执行，就是run方法不会执行，afterExecute方法也不会执行。线程池完成关闭时，调用terminated，即在所有任务已经完成，工作线程也已经关闭，terminated用来释放各种资源。
















