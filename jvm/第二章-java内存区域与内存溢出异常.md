# 第二章  java内存区域和内存溢出异常

## 运行时数据区域

总的图如下：
![java运行时数据区域][1]

### 方法区
```
功能：1.用于存储已经被虚拟机加载的 类信息，常量，静态变量，即时编译器编译后的代码等数据.
     2.是各个线程共享的内存区域.
     
虚拟机对该区域的要求： 不需要连续内存，可以选择固定大小，可以不实现垃圾收集.
    HotSpot 虚拟机会对这里进行 常量池的回收 和 类型的卸载。此区域又称为永久代（只在HotSpot中）

异常： 此区域内存无法满足需求时，抛出 OutOfMemoryError异常.
```

### java堆
```
功能： 1. 几乎所有 对象实例 和 数组 都要在堆上分配.
      2. java堆是所有线程共享的一块java虚拟机管理的区域.也是最大的一块区域.
      
介绍：java堆是垃圾回收机制回收垃圾的主要区域.其内部分为新生代 和 老年代. 还可以再细分，后面垃圾回收会说. 
     分区主要目的是：更加合理方便的回收垃圾（就是这里的无用的对象实例）
     
要求： java对可以处于物理上不连续的内存空间中，逻辑上连续即可.

异常： java堆中空间不够，并且堆无法扩展时，抛出 OutOfMemoryError.
```

### 虚拟机栈
```
功能： 1. java方法执行的内存模型.即，每个方法在执行的同时，都会创建一个栈帧。
        栈帧：用于存储局部变量表。操作数栈，动态链接，方法出口等信息.
        每一个方法从调用到执行结束，就对应着一个栈帧在虚拟机栈入栈出栈的过程.
      2. java虚拟机栈是线程私有的，他的生命周期与线程相同.
      
介绍： 1. 局部变量表：存放编译期可知的 基本数据类型，对象引用，返回类型.
      2.局部变量表在编译期间大小就完全确定，方法运行期间不会改变局部变量表的大小.
      
异常：1.栈深度大于虚拟机允许的最大深度，抛出 StackOverFlowError.
      2.虚拟机栈扩展时无法申请到足够内存,抛出 OutOfMemoryError.
      
```

### 程序计数器
```
功能：通过改变这个计数器的值（字节码的行号），来使字节码解析器取得下一条要执行的字节码指令.

介绍：1.每个线程都需要一个独立的程序计数器. 线程私有. 
      2.如果是Native方法，则计数器值为null.
      3.此内存区域是虚拟机中唯一一个没有规范任何 OutOfMemoryError的区域.
```

### 本地方法栈
```
功能：为虚拟机执行本地的Native方法服务的区域.
        Native方法就是用非java语言写的方法.
        
异常：StackOverFlowError 和 OutOfMemoryError.
```

---

> 下面介绍一下 运行时常量池

#### 运行时常量池
```
功能： 存放编译时期生成的各种 字面量 和 符号引用. 这部分内容
        将在类加载后，进入方法区的运行时常量池.直接引用在运行时被
        翻译出来也会放到该常量池.
        如：String.intern();
        
```

#### 直接内存
```
功能：不是java虚拟机中的内存，而是java通过NIO操作电脑本机存储的区域.

介绍：java的NIO通过调用Native函数库直接操纵java堆外内存，并用java堆中的
      DirectByteBuffer 对象对这块内存进行操作.

```

## HotSpot虚拟机的 对象
### 对象的创建（new 普通的java对象，不包括数组的创建）
```
1.检查参数：根据参数去常量池中查找是否有一个符号引用，并检查该符号引用代表的
        类是否被 加载，解析，初始化.如果没有，则必须先加载，解析初始化相应的类.

2.虚拟机为该对象在java堆中分配内存.对象大小，在类加载完成后，即可确定.
  至于如何分配内存区域，由不同的java虚拟机具体实现决定.
  
3.内存分配后，初始化该对象的成员变量为默认值.

4.虚拟机对 该对象的 对象头 做相应的设置.(如何找到类的元数据，对象的啊哈希码等信息)

5.按客户要求执行java代码的<init>。 对象算是创建完成了.
```

### 对象的数据结构
```
对象头： 运行时数据  和 类型指针.  (数组的话，需要一个长度数据）
        类型指针：虚拟机通过这个类型指针确定该对象是那个类的实例.(动态代理？)
        运行时数据：哈希码，锁状态标志，线程持有的锁等.
        
实例数据： 该对象的真正存储的有效信息.包括父类的信息.

对齐填充：无意义，起占位的作用.
```

### 对象的访问
> 两种方式：
通过句柄访问：
![通过句柄访问][2]
通过直接指针访问：
![此处输入图片的描述][3]

---

##关于溢出的java代码就不写了，有兴趣的可以自己google一下##



  [1]: https://upload-images.jianshu.io/upload_images/2614605-246286b040ad10c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/578
  [2]: http://dl.iteye.com/upload/attachment/534171/0823f477-035f-3549-b0cb-62ea9f673491.png
  [3]: http://dl.iteye.com/upload/attachment/534173/c76e3335-4ecb-3c0a-843b-32524316aa6c.png