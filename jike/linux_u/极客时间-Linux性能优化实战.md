# Linux性能优化实战


## CPU性能篇

### 如何理解平均负载

1. 平均负载：单位时间内，系统处于`可运行状态`和`不可中断状态`的平均进程数，也就是`平均活跃进程数`。
2. 可运行状态：正在使用CPU或者正在等待CPU的进程。ps命令处于R状态的进程。
3. 不可中断状态：进程处于内核关键流程，不可打断。ps命令处于D状态。如，一个向一个磁盘的写数据的操作，为了保证数据一致性，在得到磁盘回复前，不可被打断。
4. 不可中断状态是对系统进程和硬件设备的保护机制。
5. 查看系统cpu信息：`/proc/cpuinfo`
6. 当平均负载高于CPU数量的70%时候，需要排查。
7. 平均负载包括了可运行和不可中断进程，所以其包括了CPU进程和等待CPU和等待IO的进程。
8. CPU密集型进程，会使CPU利用率和平均负载升高；IO密集型，会使平均负载升高，但是CPU利用率不一定高。
9. mpstat：多核CPU性能分析工具，实时查看所有CPU性能指标。
10. pidstat: 进程分析工具，实时查看进程的CPU,内存，io和上线文切换等指标。

场景1

1. stress --cpu 1 --tomeout 600 模拟cpu压力
2. watch -d uptime  查看平均负载变化
3. mpstat  -P ALL 2  查看CPU使用率   
4. pidstat -u 1   查看那个进程导致  


### CPU上线文切换（上）

1. CPU寄存器是CPU内置的容量小、速度快的内存；程序计数器，用来存储CPU正在执行的指令位置或下一条位置。是CPU运行任务的前提，称为CPU的上下文。
2. 进程上下文切换：进程在CPU在系统调用和用户态的切换。一次系统条用，发生两次CPU上下文切换。同一个进程，只是发生系统调用和用户态调用的切换。
3. 进程上下文切换：进程时间片结束，会被挂起，进行切换；进程资源不足，被挂起；sleep函数，挂起；优先级造成的挂起；硬中断挂起。
4. 线程上下文：不通进程的线程的切换；同一个进程的不同线程的私有数据的切换。影响较小
5. 中断上下文切换：为了快速响应硬件的中断，会打断正常的进程调度。对内核态数据有影响。
6. 中断优先级比进程更高。


### CPU上下文切换（下）

1. vmstat工具分析系统内存使用和CPU上下文切换和中断次数

```
cs:每秒上下文切换次数；in：每秒中断次数；r:就绪队列长度，runnig和runable；b:blocked
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0 723976 8083456    204 6302096    0    0     0    11   11    3  4  1 95  0  0
 0  0 723976 8083456    204 6302096    0    0     0     0 8551  903  0  0 100  0  0

```

r和b都是0，表示现在没有运行其他任务，所以cs上线文的切换是系统的上下文切换。

---

1. pidstat -w 2

```

cswch/s:表示自愿上下文切换，指进程无法获取自愿而导致上下文切换，比如等待io、内存资源不足等  nvcswch/s：非自愿上下文切换，时间片已经到，被系统强制调度而发生的上下文切换
22时14分34秒   UID       PID   cswch/s nvcswch/s  Command
22时14分36秒     0         6      1.97      0.00  ksoftirqd/0
22时14分36秒     0         9      2.96      0.00  rcu_sched
22时14分36秒     0        11      0.49      0.00  watchdog/0
22时14分36秒     0        32      0.49      0.00  khugepaged
22时14分36秒     0       323      0.99      0.00  kworker/u256:4
22时14分36秒     0       432     19.70      0.00  xfsaild/dm-0
22时14分36秒     0      2043      2.46      0.00  kworker/0:2
22时14分36秒     0      2044      0.99      0.00  kworker/u256:1

```

---

**模拟系统多线程调度**

1. 
```
# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题
sysbench --threads=10 --max-time=300 threads run
```

2. 
```
vmstat 1
# cs上下文切换从及时到几十万，同事r队列大于2（CPU数量），表示有大量的CPU竞争；us,ys两个加起来将近100%，sy系统CPU使用率很高，说明CPU主要被内核使用；in中断也变多了，是个潜在问题
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 9  0      0 593008   4180 974800    0    0     0     0  997 911173 26 74  0  0  0
 8  0      0 593008   4180 974800    0    0     0     0  988 919360 27 73  0  0  0
 7  0      0 593008   4180 974800    0    0     0     0 1003 914031 26 74  0  0  0
 6  0      0 593008   4180 974800    0    0     0     0 1000 906671 25 75  0  0  0
 7  0      0 593008   4180 974800    0    0     0     0 1005 897993 26 74  0  0  0
 7  0      0 593008   4180 974800    0    0     0     0  999 885576 30 70  0  0  0
 8  0      0 593008   4180 974800    0    0     0     0 1006 915326 26 74  0  0  0
 9  0      0 593008   4180 974800    0    0     0     0 1000 901245 26 74  0  0  0


```
3.分析是哪些进程导致了这些问题

```
# -w表示输出线程切换指标；-u表示输出CPU使用指标
pidstat -w -u 2 
22时38分11秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
22时38分13秒     0      2223   27.00   72.00    0.00   99.00     0  sysbench
22时38分13秒     0      2254    0.00    0.50    0.00    0.50     0  pidstat

22时38分11秒   UID       PID   cswch/s nvcswch/s  Command
22时38分13秒     0         6      0.50      0.00  ksoftirqd/0
22时38分13秒     0         9      2.00      0.00  rcu_sched
22时38分13秒     0        11      0.50      0.00  watchdog/0
22时38分13秒     0       323      1.00      0.00  kworker/u256:4
22时38分13秒     0       432     20.00      0.00  xfsaild/dm-0
22时38分13秒     0      2044      1.00      0.00  kworker/u256:1
22时38分13秒     0      2069      0.50      0.00  sshd
22时38分13秒     0      2088      1.00      0.00  sshd
22时38分13秒     0      2209      4.00      0.00  kworker/0:0
22时38分13秒     0      2222      0.50      0.00  kworker/0:1
22时38分13秒     0      2234      1.00      0.00  vmstat
22时38分13秒     0      2254      0.50      0.00  pidstat

```

由cpu使用可以看出sysbench的cpu使用率很高，可以确定是sysbench占用了大量的cpu。而pidstat输出的上线文切换是不带线程的，即进程的上下文切换，使用 pidstat -w -c -t 2 ；-t 才会输出线程的信息，使用后可看出sysbench的线程有大量的上线文切换。


4.分析大量中断产生的原因
pidstat是进程的性能分析工具，不会提供中断详细信息。具体的中断类型，要通过/proc/interrupts中读取。/proc 是linux的一个虚拟文件系统，用于内核空间和用户控件的通信。

重调度中断（RES）这个中断类型表示。唤醒空闲状态的CPU来调度运行新的任务。

```
小结：
1. 自愿上线文切换变多了，说明进程在等待资源，可能发生了io等其他问题。
2. 非自愿上线文增多了，说明进程被强制调度，说明在抢cpu,说明CPU成了瓶颈。
3. 中断次数变多，说明CPU被中断处理占用，需要通过/proc/interrupts来具体分析

```


### 05 某个进程CPU使用率到达100%，怎么处理

使用 perf top这个后面再学习


### 07 系统出现大量不可中断进程和僵尸进程怎么办？


### 09 怎么理解linux软中断？

1.中断是一种异步的事件处理机制，可以提高系统的并发处理能力。中断处理程序会打断其他进程，所以尽量减少。

2.网卡接受数据包后，会通过硬件中断的方式，通知内核有新的数据到了。内核就会调用中断处理程序来相应它。上半部直接处理硬件请求，也就是硬中断，特点是快速执行；下半部是内核触发，就是常说的软中断，特点是延时执行。

3.查看软中断和硬中断的情况：/proc/softirqs 软中断   /proc/interrupts 硬中断

4.watch -d cat /proc/softirqs 查看软中断数据
```

NET_RX:网络接收中断；NET_TX：网络发送中断；TIMER定时中断；RCU锁

                    CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       
          HI:          1          0          0          0          0          0
       TIMER:     265439     299019     221342     266167     189161     191341
      NET_TX:          0          0          0          2          0          1
      NET_RX:    1529543    3336488    1241491    1271615       3246       4715
       BLOCK:          0          0          0          0          0          0
BLOCK_IOPOLL:          0          0          0          0          0          0
     TASKLET:         16          0          0          0          0          0
       SCHED:      58182      43811      39343      42283      32768      33954
     HRTIMER:          0          0          0          0          0          0
         RCU:     216152     254951     182028     210210     153170     156338
```

### 10 系统软中断CPU使用率升高？

1. 在linxu中，每个CPU对应一个软中断内核线程，名字是ksoftirqd/CPU编号。中断事件频率过高，内核线程也会因为CPU使用率过高而导致软中断处理不及时，进而导致网络收发延迟，调度缓慢等性能问题。
2. sar:是一个系统活动报告工具，既可以实时查看系统活动，又可以保存和报告历史统计数据。
3. hping3构造TCP/IP协议数据包的工具，可以对系统安全审计、防火墙测试。
4. tcpdump是一个网络抓包工具，常用来分析网络问题。
5. sar 用来查看系统的网络收发情况，可以观察到网络收发的吞吐量和网络收发的pps，即每秒的网络帧数。
```
第一列：报告时间；IFACE表示网卡；rxpck/s、txpck/s分别表示每秒收到和发送的网络包；rxkB/s、txkB/s分别表示每秒接受、发送的千字节数
22时01分13秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
22时01分14秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
22时01分14秒     ens33      1.98      0.99      0.12      0.40      0.00      0.00      0.00

22时01分14秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
22时01分15秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
22时01分15秒     ens33      1.98      0.99      0.12      0.40      0.00      0.00      0.00
```

6.tcpdump 抓包
```
# -i eth0 只抓取eth0网卡，-n 不解析协议名和主机名，tcp port 80 只抓取tcp协议且端口80的网络包
tcpdump -i eth0 -n tcp port 80
```























### 11 迅速分析系统CPU的瓶颈在哪

1. CPU使用率的问题
 - 用户CPU使用率(us)和低优先级CPU使用率(nice)。表示CPU在用户态运行的时间百分比。用户CPU使用率高，说明应用程序比较繁忙。
 - 系统CPU使用率(sy)不包括中断，说明系统内核比较忙。
 - 等待IO的CPU使用率比较，也叫iowait,表示等待io时间的百分比。
 - 软中断si和硬中断hi使用率。
 - 虚拟化环境中，窃取CPU的使用率st和客户CPU使用率；分别表示被其他虚拟机占用的CPU时间百分比和运行客户虚拟机CPU时间百分比。
2. 平均负载，活跃进程数
3. 上下文切换

![此处输入图片的描述][1]

![此处输入图片的描述][2]

 


  [1]: https://static001.geekbang.org/resource/image/1e/07/1e66612e0022cd6c17847f3ab6989007.png
  [2]: https://static001.geekbang.org/resource/image/7a/17/7a445960a4bc0a58a02e1bc75648aa17.png