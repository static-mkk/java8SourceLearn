

## redis 过期策略有哪些？

有定期删除和惰性删除

1. 定期删除：指redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查是否过期，过期就删除。 切记，是抽查，如果100ms就遍历所有设置了过期时间的key，会非常影响性能。

2. 惰性删除：如果很多key到了过期时间并没有删除，怎么办？ 实际上在你获取某个key的时候，redis会检查这个key是否过期。如果过期就会删除，不给你返回内容。


如果很多key没有定期删除，也没有及时的查询这个key，那就会有很多对象在redis中堆积。怎么办？

3. 内存淘汰机制：
    
    - allkeys-lru: 当内存不注意容纳新写入数据时，溢出最近最少使用的key
    - allkeys-random:当内存不足以写入内存，随机洗出某个key
    - volatile-lru:在设置了过期时间的key中，溢出最少使用的key
    - volatile-random：在设置了过期时间的key中，随机溢出某个key
    - volatile-ttl：在设置了过期时间的key中，移除更早的key


## redis缓存问题

### redis缓存雪崩

某个时间段，用于提供redis缓存的设备宕机或者redis服务异常，然后瞬间会有大量的请求落到了数据库，导致数据库扛不住。这就叫缓存雪崩。

处理方式：1.redis提供集群主从，提高可用性。事前。 2.使用限流机制，降低访问量，避免mysql被打死。事中。3.redis持久化，一旦重启，自动从磁盘上加载数据。快速回复服务。

### redis缓存穿透

情景：加入每秒 5000请求，其中4000为恶意请求。这4千请求中，在redis缓存中查不到，在数据库中也查不到，这样就会导致，这部分穿透了缓存，直接访问了数据库。就会大数据库打死。这就叫缓存穿透。


解决方案：每次对从数据库中没查到的数据，和请求的key做绑定，并设置到redis中，并设置过期时间，在一定时间内，下次再有相同的key请求，就直接返回null处理。

如果恶意请求的key很多，也是会导致很多流量跑到数据库中，并且还会导致redis中添加很多无用的数据，占用了内存。

### redis缓存击穿

场景：如果某个key非常热点，在这个key失效的瞬间，就会有大量的请求直接击穿缓存，访问数据库。这就是缓存击穿。

解决方案：1.如果缓存的数据基本不会发生更新，尝试吧热点数据设置成不过期。

## 缓存和数据库的双写不一致

场景：使用时用了缓存和数据库，就会又数据库和缓存数据不一致的情况，如何处理？

解决方案：读请求和写请求串行化，串行到一个队列里面去。 这样会大大的降低性能。

常见的解决方案：cache aside pattern

    - 读的时候，先读缓存，缓存没有再去读数据库，然后放到缓存，同时相应
    - 写的时候，先写数据库，然后删除缓存。
    
    
为什么是删除缓存，而不是更新缓存？
    
    - 因为如果如果一行的某个字段是另外表的某些值，计算之后的结果，那么此时更新缓存，字段的值就是此时的计算结果，而后面如果相应字段改变，那么这个缓存中字段的值就会是过期的。
    - 缓存更新频繁，也会有性能影响。【做缓存的目的不就是应对读多的请求吗，所以面对读多的请求，频繁更新应该是可以的】


缓存不一致的情况？
先删除数据库，在删除缓存，如果删除缓存失败，那么数据库中的最新的数据，而缓存是旧数据，所以就会出现缓存不一致。

解决办法：先删除缓存，在更新数据库。

新问题：如果并发量很高，在你删除缓存后，更新数据库操作之前，新请求读取数据库，但是此时数据库的数据还是旧的。还是会读到旧数据。

解决方案，在更新数据库和读取数据库的操作串行到同一个队列中，这样就能保证其先后顺序。

这样就会有很多消费队列的问题了.比如rabbirmq的重复消费问题，超时问题等等。

    

    
    















