

# redis原理 知识点

## 原理1：线程IO模型

redis是个单线程的程序。

redis单线程为什么还这么快？

    因为他的所有数据都是在内存中的，所有的运算都是内存级别的运算。因为redis是单线程，所以对于一些时间复杂度为O(n)的指令，一定要慎用，可能会导致redis卡顿。

redis单线程如何处理那么多并发客户端连接？

    redis的socket为同步非阻塞io，基于select的事件轮询的api（多路复用）。同netty一样。一个线程通过注册的select，可以监听大量的socket请求。


事件轮询（多路复用）
    
    
    非阻塞io有个问题，就是线程读数据，读了一部分就返回了，线程如何才能知道应该继续读。也就是当数据来时，线程如何得到通知。写也是一样，如果缓冲区满了，写不完，剩下的数据何时才能继续写，线程也应该得到通知。
    事件轮询api就是来解决这个问题的。
    最简单的事件轮询api就是select函数，他的输入时读写描述符列表read_fds & write_fds，输出是对应的可读，可写的事件。同时提供一个timeout参数，没有事件到来，就阻塞wimeout事件，如果有任何事件到来，就可以立即返回，处理相应的事件。处理完后，就继续进行轮询。线程就进入了一个死循环，称之为事件循环。和netty的处理write和read的nioeventloop相同。
    

指令队列

    redis会将每个客户端套接字都关联到一个指令队列。客户端的指令通过队列来排队顺序处理，先到先服务。
    

响应队列

    
    redis会为每个客户端套接字关联一个响应队列。redis通过响应队列来将指令的结果返回给客户端。如果队列为空，那么连接暂时处于空闲状态，不需要获取写事件，可以把当前描述符从write_fds里面移出来，避免select系统调用时，理解返回写事件，结果没有数据可写，导致线程CPU飙升。
    

定时任务

    redis如何在线程阻塞在select系统调用时，定时任务将无法得到准时调度？
    redis的定时任务会记录一个最小堆的数据结构中。最快要执行的任务排在堆的最上面。每个循环周期，redis都会处理已经到点的任务。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是 select 系统调用的 timeout 参数。
    
    
    
    
    
## 原理2：通信协议

redis作者认为数据库的瓶颈一般不在于网络流量，而是数据库自身内部逻辑。所以redis 使用了浪费流量的文本协议。

RESP是redis序列化协议的简写。是一种直观的文本协议，优势在于实现简单，解析性能极好。

redis将传输的数据结构分为5中最小单元类型，单元结束时同意加上 回车换行符。

1. 单行字符串  +开头
2. 多行字符串  以 $ 开头，后跟字符串长度
3. 整数值  以 : 符号开头，后跟整数的字符串形式
4. 错误消息  以 - 开头
5. 数组 以*开头，后跟数组长度


## 原理3：持久化

redis的数据全部存储在内存中，如果发生宕机，数据会全部丢失。所以需要持久化。redis有2中持久化机制，第一种是快照，第二种AOF日志。快照试一次全量备份，AOF日志时连续的增量备份。

快照文件是内存数据的二进制序列化形式，在存储上非常紧凑。而AOF日志记录的是内存数据修改的指令记录文本。

AOF日志在昌吉运行过程中会增长的很大，数据库重启时需要加载AOF进行指令重放，非常耗时。所以需要定期进行AOF重写，给AOF日志瘦身。



快照原理：

    在服务线上请求进行内存快照的同事，内存快照还需要进行文件IO，文件IO不能使用多路复用。又因为redis是单线程，执行文件io会严重影响性能。还有就是为了不影响业务，就需要边持久化边响应服务。redis使用操作系统COW(copy on write)机制来完成快照。redis在持久化时会调用glibc的函数fork产生一个子进程，快照持久化由子进程来处理，父进程继续处理客户端请求。紫荆城刚刚产生时，和父进程共享内存里面的代码段和数据段。子进程只会遍历读取内存数据，然后序列化写到磁盘。父进程继续进行处理请求，当父进程修改数据时，会利用操作系统的COW机制来进行数据段页面的分离，所以父进程是在复制出来的内存上进行修改的，不会影响子进程的数据。
    

AOF原理：

    AOF是存储redis服务器的顺序指令序列，只记录对内存进行修改的指令记录。


AOF重写：
    
    redis的bgrewriteaof指令用于对AOP日志文件的瘦身。原理就是开辟一个子进程对内存进行遍历，转化成一系列redis的操作指令，序列化出一个信封AOF文件，期间发生的增量AOF日志会最佳到新的AOF文件中。追加完毕后，就替代旧的AOF日志文件了。
    
    
fsync

    AOF日志是以文件的形式存在的，当程序对AOF日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步的将脏数据刷回到磁盘。所以发生宕机，可能出现AOF日志丢失。使用linux的glibc提供的fsync函数，可以将制定文件的内容强制从内核缓存中刷到磁盘。可以保证aof日志不会丢失。fsync是一个磁盘io，很慢。圣餐环境中，redis通常每个1s左右会执行一次fsync操作，周期是可以配置的。


## 原理4：管道

write和read的真正网络开销，是在相应的缓冲区满了或者为空时，需要的等待时间。多个网络的read操作，就需要等待多个客户端的消息在网络中都发过来，才能全部读取，而用pipeline可以把多个操作合在一起发送，就可以减少read操作等待一个网络包来回的开销。管道是客户端改变了读写的顺序，带来的性能提升。

## 原理5：事务

redis的事务并不是完全的事务，在事务中间的命令发生失败时，事务后面的命令可以继续运行，所以并不保证原子性。

DISCARD（丢弃） 可以丢弃掉事务队列中的所有指令。

在执行事务的时候，如果不同客户端对同一个元素修改，就会引起并发问题，所以解决并发问题，就需要使用锁，入redis的分布式锁。但是分布式锁是一种悲观锁。redis提供了watch机制来实现乐观锁。

    即在事务开始之前，使用watch来观察某些变量，如果变量被修改，在事务通过exec执行时，方法会返回一个null，说明在执行事务时，有其他客户端修改了watch的变量，出现了并发，就需要不断地重试。死循环重试。这样其实也不好，如果并发性高的话，可能会导致cpu升高，所以可以每隔一段时间进行重试。或者使用分布式锁。



## 原理8：有备无患 -- 主从同步

### CAP 原理

- C - Consistent 一致性
- A - Availability 可用性
- P - Partition tolerance 分区容忍性

分布式系统的节点都是以网络隔离的，分布在不同的机器上的，所以会出现网络断开的风险。这个网络断开的专业场景叫【网络分区】。


网络分区发生时，一致性和可用性难两全。


最终一致性：
    
    redis 的主从数据时异步同步的，所以分布式的redis不能满足【一致性】要求。当客户端在redis的主节点修改数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以redis满足【可用性】。
    redis最终一致性保证，当网络断开时出现了大量数据不一致的情况，在网络恢复后，从节点会采用多种策略同步数据，努力和主节点保持一致。
    

主从同步：
    
    redis支持主从同步和从从同步，以减轻主节点压力。
    
    
增量同步：
    
    redis同步的是指令流，主节点会把哪些对自己的状态产生修改性影响的指令记录在本地的内存buffer中，然后异步的将buffer中的执行同步到从节点。
    因为内存的buffer是有限的，是个订场的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。
    
    
快照同步：

    当buffer用完，从节点就无法通过指令流进行同步，这个时候就需要更加复杂的同步机制-快照同步。
    快照同步是一个非常耗费资源的操作，他需要在主库上进行一次 bgsave ,将当前内存的数据全部快照到文件中，然后再讲快照的内容全部传到从节点。从节点将快照接受完毕后，立即执行一次全量加载，加载前先将当前数据清空。加载完毕后，通知主节点继续进行增量同步。
    在快照同步的过程中，主节点的复制buffer还在不停的移动，如果快照同步的时间太长，或者复制buffer太小，都会导致同步期间增量指令在buffer中被覆盖。就会又发生快照同步，可能会陷入一个死循环。
    

无盘复制：

    主节点在进行快照同步时，会进行很重的文件IO操作，会对系统产生较大影响。特别是当系统正在进行AOF的fsync时，fsync操作就会被推迟，会严重影响主节点的服务效率。
    从redis 2.8版本开始支持误判复制。就是主服务器通过socket将快照内容发送到从节点，一遍遍历内存，一遍将序列话的内容发送给从节点；从节点接收到内容后，先将内容存储的磁盘文件中，在进行一次性加载。
    


    
    
    
    
    








